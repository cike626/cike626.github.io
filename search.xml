<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cunit单元测试</title>
    <url>/posts/794/</url>
    <content><![CDATA[<h2 id="1、CUnit简介"><a href="#1、CUnit简介" class="headerlink" title="1、CUnit简介"></a>1、CUnit简介</h2><p>CUnit 是一个通过 C 语言编写的用于编写、管理和执行单元测试用例的C语言<a href="https://baike.baidu.com/item/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/1917084">单元测试</a>框架。<br>它往往被编成库的形式（静态库或动态库）提供给用户测试代码进行使用，用户编写程序的时候直接链接此静态库就可以了。</p>
<p>它提供了一个简单的单元测试框架，并且为常用的数据类型提供了丰富的断言语句支持。</p>
<p>CUnit是平台无关的框架与各种用户接口的组合。核心框架为管理测试注册表，套件和测试用例提供了基本支持。用户接口便于与框架交互以运行测试和查看结果。CUnit的组织结构与传统的单元测试框架类似：</p>
<span id="more"></span>
<p><img src="/posts/794/cunit_registry.jpg" alt="cunit_registry"></p>
<p>单独的测试用例（Test）被打包到套件（Suite）中，这些套件又被注册到活动测试注册表（Test Registry）里。每个套件都有自己的构造和析构函数，这两个函数将在运行套件测试之前和之后被自动调用。注册表中的所有套件/测试用例，可以通过调用一个函数执行全部测试，也可以有选择性地执行部分测试。</p>
<h2 id="2、CUnit安装"><a href="#2、CUnit安装" class="headerlink" title="2、CUnit安装"></a>2、CUnit安装</h2><ul>
<li><p><a href="http://cunit.sourceforge.net/">CUnit的首页</a></p>
</li>
<li><p><a href="http://cunit.sourceforge.net/doc/index.html">CUnit 的文档手册地址</a></p>
</li>
<li><p><a href="https://blog.csdn.net/benkaoya/article/details/95887879">中文翻译版</a></p>
</li>
<li><p><a href="http://sourceforge.net/projects/cunit/?source=typ_redirect">CUnit 2-1-3下载地址</a></p>
</li>
</ul>
<h3 id="2-1、安装配置——Ubuntu"><a href="#2-1、安装配置——Ubuntu" class="headerlink" title="2.1、安装配置——Ubuntu"></a>2.1、安装配置——Ubuntu</h3><p>软件源中与CUnit相关的包有:</p>
<blockquote>
<p>libcunit1 libcunit1-dev libcunit1-doc libcunit1-ncurses libcunit1-ncurses-dev</p>
</blockquote>
<p>使用<code>apt-get install</code>安装即可。</p>
<h3 id="2-2、安装步骤"><a href="#2-2、安装步骤" class="headerlink" title="2.2、安装步骤"></a>2.2、安装步骤</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -jxvf CUnit-2.1-3.tar.bz2</span><br><span class="line">cd CUnit-2.1-3</span><br><span class="line">libtoolize -f -c -i</span><br><span class="line">aclocal</span><br><span class="line">autoconf</span><br><span class="line">autoheader</span><br><span class="line">automake</span><br><span class="line">chmod u+x configure</span><br><span class="line">./configure –prefix=/opt/cunit</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="2-3、安装文件目录树"><a href="#2-3、安装文件目录树" class="headerlink" title="2.3、安装文件目录树"></a>2.3、安装文件目录树</h3><p>cunit安装成功后会生成4个文件夹：<strong>doc、include、lib、share</strong>。</p>
<p><strong>doc</strong>目录是一些简介以及使用说明。<br><img src="/posts/794/cunit_install_doc.png" alt="install"></p>
<p><code>include</code>和<code>lib</code>目录中是我们需要的头文件以及库文件。</p>
<p><img src="/posts/794/cunit%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6.png" alt="install_1"></p>
<p><strong>share</strong>目录中有<strong>Automated</strong>模式下需要的文件。</p>
<p><img src="/posts/794/cunit_install_share.png" alt="install_2"></p>
<h2 id="3、CUnit使用介绍"><a href="#3、CUnit使用介绍" class="headerlink" title="3、CUnit使用介绍"></a>3、CUnit使用介绍</h2><h3 id="3-1、输出方式"><a href="#3-1、输出方式" class="headerlink" title="3.1、输出方式"></a>3.1、输出方式</h3><table>
<thead>
<tr>
<th align="left">接口</th>
<th>平台</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Automated</td>
<td>All</td>
<td align="left">非交互式，输出XML文件</td>
</tr>
<tr>
<td align="left"><strong>Basic</strong></td>
<td><strong>All</strong></td>
<td align="left"><strong>非交互式，可选输出到stdout</strong></td>
</tr>
<tr>
<td align="left">Console</td>
<td>All</td>
<td align="left">控制台交互方式，在用户控制下运行</td>
</tr>
<tr>
<td align="left">Curses</td>
<td>Linux/Unix</td>
<td align="left">Curses交互方式（图形界面），在用户控制下运行</td>
</tr>
</tbody></table>
<p>如上边所示，后两种主要是interactive的接口，就是我们可以交互式地指定参数，然后观察结果。在我们具体的环境下，我们通常使用上面两种接口，第一种是将结果输出到XML文档中，便于我们生成报告。第二种仅仅是每一次运行结束之后，在standard output中显示，不能保留测试结果数据。</p>
<p>我们可以将前两种输出结合起来，自己测试的时候，使用<strong>Basic</strong>模式，生成报告的时候，使用<strong>Automated</strong>模式。</p>
<blockquote>
<p>注：在Curse输出模式下需要联接  <code>-lncurses</code></p>
</blockquote>
<h3 id="3-2、输出方式对应的接口函数"><a href="#3-2、输出方式对应的接口函数" class="headerlink" title="3.2、输出方式对应的接口函数"></a>3.2、输出方式对应的接口函数</h3><table>
<thead>
<tr>
<th>模式</th>
<th>使用的接口函数</th>
</tr>
</thead>
<tbody><tr>
<td>Basic</td>
<td>#include “CUnit/Basic.h”<br>CU_basic_set_mode(CU_BRM_VERBOSE);<br>CU_basic_run_tests();</td>
</tr>
<tr>
<td>Automated</td>
<td>#include “CUnit/Automated.h”<br>CU_list_tests_to_file();<br>CU_automated_run_tests();</td>
</tr>
<tr>
<td>Console</td>
<td>#include “CUnit/Console.h”<br>CU_console_run_tests();</td>
</tr>
<tr>
<td>Curses</td>
<td>#include “CUnit/CUCurses.h”<br>CU_curses_run_tests();</td>
</tr>
</tbody></table>
<p>配置使用<em><strong>Basic</strong></em>模式，运行的结果如下。</p>
<p><img src="/posts/794/cunit_basic.png" alt="install_3"></p>
<p>配置使用<em><strong>Automated</strong></em>模式，重新编译运行后会生成<code>CUnitAutomated-Listing.xml</code>和<code>CUnitAutomated-Results.xml</code>两个文件。文件名是在不设定的情况下，使用默认文件名。</p>
<p>把项目生成的<code>CUnitAutomated-Listing.xml</code>和<code>CUnitAutomated-Results.xml</code>，与CUnit安装目录下的<code>CUnit-List.dtd</code>、<code>CUnit-List.xsl</code>、<code>CUnit-Run.dtd</code>和<code>CUnit-Run.xsl</code>，共六个文件，放到一个文件夹下，拷贝到window系统下，使用IE浏览器打开。</p>
<blockquote>
<p><strong>注意</strong>，要用IE浏览器进行打开，谷歌浏览器和狐火浏览器都无法正确打开。</p>
</blockquote>
<center>
    TestMax-Results.xml

</center>

<p><img src="/posts/794/cunit_automated_result.png" alt="cunit_automated_result"></p>
<center>
    TestMax-Listing.xml

</center>

<p><img src="/posts/794/cunit_automated_listing.png" alt="cunit_automated_listing"></p>
<h3 id="3-3、测试函数的书写"><a href="#3-3、测试函数的书写" class="headerlink" title="3.3、测试函数的书写"></a>3.3、测试函数的书写</h3><p>1） 首先针对被测试的函数书写测试函数。</p>
<p>2） 初始化一个Registry。</p>
<p>3） 将特定的Suite加入到这个<em>Registry</em>中。可以为<em>Suite</em>指定初始化函数和清理函数。</p>
<p>4） 将测试函数加入到一个<em>Suite</em>中，这样，如果该测试函数的运行需要一些初始化条件，那么可以可以将代码加入到<em>Suite</em>的初始化函数中，当然不要忘记最后还要做对应的清理操作。</p>
<p>5） 使用相应的接口将测试结果输出。</p>
<p>6） 最后，清理Registry。</p>
<h3 id="3-4、CUnit-断言"><a href="#3-4、CUnit-断言" class="headerlink" title="3.4、CUnit 断言"></a>3.4、CUnit 断言</h3><p>CUnit提供了大量的预定义的断言，针对几乎所有的C的标准类型，我们可以针对具体的需要检查的参数的类型进行选择。</p>
<p><strong>CUnit 对断言定义如下：</strong></p>
<table>
<thead>
<tr>
<th><strong>CU_ASSERT</strong> (int expression)<br><strong>CU_ASSERT_FATAL</strong> (int expression)<br><strong>CU_TEST</strong> (int expression)<br><strong>CU_TEST_FATAL</strong> (int expression)</th>
<th>断言表达 expression 是 CU_TRUE（非零）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CU_ASSERT_TRUE</strong> (value)<br><strong>CU_ASSERT_TRUE_FATAL</strong> (value)</td>
<td>断言值 value 是 CU_TRUE（非零）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_FALSE</strong> (value)<br><strong>CU_ASSERT_FALSE_FATAL</strong> (value)</td>
<td>断言值 value 是 CU_FALSE（零）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_EQUAL</strong> (actual, expected)<br><strong>CU_ASSERT_EQUAL_FATAL</strong> (actual, expected)</td>
<td>断言 actual （实际） == expected （预期）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_NOT_EQUAL</strong>(actual, expected)<br><strong>CU_ASSERT_NOT_EQUAL_FATAL</strong> (actual,expected)</td>
<td>断言 actual （实际） != expected（预期）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_PTR_EQUAL</strong> (actual, expected)<br><strong>CU_ASSERT_PTR_EQUAL_FATAL</strong> (actual,expected)</td>
<td>断言 指针 actual（实际） == expected （预期）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_PTR_NOT_EQUAL</strong> (actual,expected)<br><strong>CU_ASSERT_PTR_NOT_EQUAL_FATAL</strong> (actual, expected)</td>
<td>断言 指针 actual（实际） != expected （预期）</td>
</tr>
<tr>
<td><strong>CU_ASSERT_PTR_NULL</strong> (value)<br><strong>CU_ASSERT_PTR_NULL_FATAL</strong> (value)</td>
<td>断言 指针 value == NULL</td>
</tr>
<tr>
<td><strong>CU_ASSERT_PTR_NOT_NULL</strong> (value)<br><strong>CU_ASSERT_PTR_NOT_NULL_FATAL</strong> (value)</td>
<td>断言 指针 value != NULL</td>
</tr>
<tr>
<td><strong>CU_ASSERT_STRING_EQUAL</strong> (actual,expected)<br><strong>CU_ASSERT_STRING_EQUAL_FATAL</strong> (actual, expected)</td>
<td>断言的实际和预期的字符串是等价的<br>strcmp</td>
</tr>
<tr>
<td><strong>CU_ASSERT_STRING_NOT_EQUAL</strong><br> (actual,expected)<br><strong>CU_ASSERT_STRING_NOT_EQUAL_FATAL</strong><br>(actual, expected)</td>
<td>断言字符串的实际和预期不同</td>
</tr>
<tr>
<td><strong>CU_ASSERT_NSTRING_EQUAL</strong> (actual,expected, count)<br><strong>CU_ASSERT_NSTRING_EQUAL_FATAL</strong> <br>(actual, expected, count)</td>
<td>断言的实际和预期的前count个字符是相同的<br>strncmp</td>
</tr>
<tr>
<td><strong>CU_ASSERT_NSTRING_NOT_EQUAL</strong><br> (actual,expected, count)<br><strong>CU_ASSERT_NSTRING_NOT_EQUAL_FATAL<br></strong>(actual, expected, count)</td>
<td>断言前count个字符的实际和预期的不同</td>
</tr>
<tr>
<td><strong>CU_ASSERT_DOUBLE_EQUAL</strong><br> (actual,expected, granularity)<br><strong>CU_ASSERT_DOUBLE_EQUAL_FATAL<br></strong> (actual, expected, granularity)</td>
<td>Assert that fabs(actual - expected) &lt;= fabs(granularity)<br>Math library must be linked in for this assertion</td>
</tr>
<tr>
<td><strong>CU_ASSERT_DOUBLE_NOT_EQUAL</strong><br> (actual,expected, granularity)<br><strong>CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL<br></strong>(actual, expected, granularity)</td>
<td>Assert that fabs(actual - expected) &gt;fabs(granularity)<br>Math library must be linked in for this assertion</td>
</tr>
<tr>
<td><strong>CU_PASS</strong> (message)</td>
<td>注册一个指定的通过断言的消息。不可进行逻辑测试。</td>
</tr>
<tr>
<td><strong>CU_FAIL</strong> (message)<br><strong>CU_FAIL_FATAL</strong> (message)</td>
<td>注册一个指定的失败断言的消息。不可进行逻辑测试。</td>
</tr>
</tbody></table>
<p>可以看到，每一种类型的断言都有<em><strong>FATAL</strong></em>和非<em><strong>FATAL</strong></em>两个函数，他们的区别是，非<em><strong>FATAL</strong></em>断言失败的时候，程序继续运行，而<em><strong>FATAL</strong></em>类型的断言失败之后，程序马上中止。通常我们使用非<em><strong>FATAL</strong></em>就可以了。</p>
<p>注意在我们的程序中，需要对返回值，<em><strong>out</strong></em>参数进行判断，对于是否是预想结果的判断的时候，一定要使用断言，而不要使用*<code>printf</code><em>等等函数，一方面</em><code>printf</code>*缺乏灵活性，另一方面，只有使用断言，结果报告中才会有对应的输出项。</p>
<p><strong>CU_PASS</strong>，<strong>CU_FAIL</strong>这两个断言比较特殊，它们仅仅表示测试程序运行到了这个地方。比如，在某些测试函数中，被测试的函数没有任何返回值等，我们为了证明这个函数已经被运行到了，我们使用以上两个函数。它们仅仅打印出一条消息，代表执行过。还有就是，它们也被输出。</p>
<h2 id="4、CUnit使用实例"><a href="#4、CUnit使用实例" class="headerlink" title="4、CUnit使用实例"></a>4、CUnit使用实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CUnit/Automated.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CUnit/Basic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CUnit/CUnit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CUnit/Console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CUnit/TestDB.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suite_success_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suite_success_clean</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fun1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fun2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">CU_TestInfo test_cases[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test1&quot;</span>, test_fun1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;test2&quot;</span>, test_fun2&#125;,</span><br><span class="line">    CU_TEST_INFO_NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CU_SuiteInfo suites[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;test_cases:&quot;</span>, suite_success_init, suite_success_clean, <span class="literal">NULL</span>, <span class="literal">NULL</span>, test_cases&#125;,</span><br><span class="line">    CU_SUITE_INFO_NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CU_initialize_registry()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; Initialization of Test Registry failed. &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(<span class="literal">NULL</span> != CU_get_registry());</span><br><span class="line">		assert(!CU_is_test_running());</span><br><span class="line">		<span class="keyword">if</span> (CUE_SUCCESS != CU_register_suites(suites)) &#123;</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">		<span class="comment">/**** Automated Mode *****************/</span></span><br><span class="line">		CU_set_output_filename(<span class="string">&quot;TestMax&quot;</span>);</span><br><span class="line">		CU_automated_run_tests();</span><br><span class="line">		CU_list_tests_to_file();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">//***** Basice Mode *******************</span></span><br><span class="line">		CU_basic_set_mode(CU_BRM_VERBOSE);</span><br><span class="line">		CU_basic_run_tests();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        CU_cleanup_registry();</span><br><span class="line">        <span class="keyword">return</span> CU_get_error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	gcc -o test testcase.c -I./<span class="keyword">include</span> -L./lib -lcunit</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>cunit</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/posts/43167/</url>
    <content><![CDATA[<h2 id="1、创建git版本库"><a href="#1、创建git版本库" class="headerlink" title="1、创建git版本库"></a>1、创建git版本库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ubuntu:~/git$ git init </span><br><span class="line">Initialized empty Git repository in /home/aston/git/.git/</span><br></pre></td></tr></table></figure>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>
<h3 id="1-1、把文件添加到版本库"><a href="#1-1、把文件添加到版本库" class="headerlink" title="1.1、把文件添加到版本库"></a>1.1、把文件添加到版本库</h3><span id="more"></span>
<p>创建一个文件，写入一些内容，和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令<strong>git add</strong>告诉Git，把文件添加到仓库：</p>
<blockquote>
<p>$ git add readme.txt</p>
</blockquote>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<strong>git commit</strong>告诉Git，把文件提交到仓库：</p>
<blockquote>
<p>$ git commit -m “wrote a readme file”<br>[master (root-commit) eaadf4e] wrote a readme file<br>1 file changed, 2 insertions(+)<br>create mode 100644 readme.txt</p>
</blockquote>
<p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<blockquote>
<p>git add file1.txt<br>git add file2.txt file3.txt<br>git commit -m “add 3 files.”</p>
</blockquote>
<p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件。修改后，运行<strong>git status</strong>命令看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ubuntu:~/git$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aston@ubuntu:~/git$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 0d8382e..3afc585 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -5,4 +5,3 @@ Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git </span><br><span class="line">-check branch master</span><br></pre></td></tr></table></figure>

<p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在最后一行删除了check branch master。</p>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<strong>git add</strong>，同样没有任何输出。在执行第二步<strong>git commit</strong>之前，我们再运行<strong>git status</strong>看看当前仓库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aston@ubuntu:~/git$ git status </span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：</p>
<blockquote>
<p>aston@ubuntu:~/git$ git commit -m “dd readme “<br>[master 7c56830] dd readme<br>1 file changed, 1 deletion(-)</p>
</blockquote>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<blockquote>
<p>aston@ubuntu:~/git$ git status<br>On branch master<br>nothing to commit, working directory clean</p>
</blockquote>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<strong>git log</strong>命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aston@ubuntu:~/git$ git log</span><br><span class="line">commit 7c56830bd6f60d6c6a35efed6aa33de4875ee89b</span><br><span class="line">Author: linux &lt;ARM@linux.com&gt;</span><br><span class="line">Date:   Wed Jul 4 16:48:23 2018 +0800</span><br><span class="line"></span><br><span class="line">    dd readme</span><br><span class="line"></span><br><span class="line">commit 07c23066dc8c104647ab20214d456a5bc5f4a4f6</span><br><span class="line">Author: linux &lt;ARM@linux.com&gt;</span><br><span class="line">Date:   Wed Jul 4 16:45:30 2018 +0800</span><br><span class="line"></span><br><span class="line">    修改readme文件</span><br></pre></td></tr></table></figure>

<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上**–pretty=oneline**参数：</p>
<h3 id="1-2、版本库"><a href="#1-2、版本库" class="headerlink" title="1.2、版本库"></a>1.2、版本库</h3><p>工作区有一个隐藏目录**.git**，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<strong>master</strong>，以及指向<strong>master</strong>的一个指针叫<strong>HEAD</strong>。</p>
<p><img src="/posts/43167/git_1.2.png"></p>
<p>分支和HEAD的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<strong>git add</strong>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<strong>git commit</strong>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<strong>master</strong>分支，所以，现在，<strong>git commit</strong>就是往<strong>master</strong>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>通过<strong>git add</strong>将修改过的文件添加到暂存区。</p>
<p><img src="/posts/43167/git_1.2.2.png"></p>
<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="/posts/43167/git_1.2.3.png" alt="git-1.2.3"></p>
<h3 id="1-3、撤销修改"><a href="#1-3、撤销修改" class="headerlink" title="1.3、撤销修改"></a>1.3、撤销修改</h3><p>Git会告诉你，<strong>git checkout – file</strong>可以丢弃工作区的修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure>

<p>命令<strong>git checkout – readme.txt</strong>意思就是，把<strong>readme.txt</strong>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<strong>readme.txt</strong>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<strong>readme.txt</strong>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<strong>git commit</strong>或<strong>git add</strong>时的状。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<strong>git checkout – file</strong>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令**git reset HEAD <file>**，就回到了场景1，第二步按场景1操作。</file></p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<code>版本回退</code>一节，不过前提是没有推送到远程库。</p>
<h3 id="1-4、删除文件"><a href="#1-4、删除文件" class="headerlink" title="1.4、删除文件"></a>1.4、删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交；<br>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<blockquote>
<p>$ rm test.txt</p>
</blockquote>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<strong>git status</strong>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">deleted:    test.txt</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<strong>git rm</strong>删掉，并且<strong>git commit</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line">git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<blockquote>
<p>$ git checkout – test.txt</p>
</blockquote>
<p><strong>git checkout</strong>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="1-5、版本回退"><a href="#1-5、版本回退" class="headerlink" title="1.5、版本回退"></a>1.5、版本回退</h3><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aston@ubuntu:~/git$ git log --pretty=oneline</span><br><span class="line">67d809fe71f2cec49fa95544e3f7d303fce1afd1 测试git rm</span><br><span class="line">10970fc3ff8b65bf794c55d05a91d5e9317259a1 添加src代码</span><br><span class="line">b794c9d5cd42c87948f6bd79dcdbd3c78885f57d add 2 file start</span><br></pre></td></tr></table></figure>

<p>需要友情提示的是，你看到的一大串类似1094adb…的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<blockquote>
<p>$ git reset –hard HEAD^<br>HEAD is now at e475afc add distributed</p>
<p>$ git reset –hard 1094a<br>HEAD is now at 83b0afe append GPL</p>
</blockquote>
<p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。<br>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？<br>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<p><strong>现在总结一下：</strong></p>
<blockquote>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p>
</blockquote>
<blockquote>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
</blockquote>
<blockquote>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</blockquote>
<h2 id="2、分支管理"><a href="#2、分支管理" class="headerlink" title="2、分支管理"></a>2、分支管理</h2><h3 id="2-1、创建分支"><a href="#2-1、创建分支" class="headerlink" title="2.1、创建分支"></a>2.1、创建分支</h3><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<strong>master</strong>分支。<strong>HEAD</strong>严格来说不是指向提交，而是指向<strong>master</strong>，<strong>master</strong>才是指向提交的，所以，<strong>HEAD</strong>指向的就是当前分支。</p>
<p>一开始的时候，<strong>master</strong>分支是一条线，Git用<strong>master</strong>指向最新的提交，再用<strong>HEAD</strong>指向<strong>master</strong>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="/posts/43167/git_2.1.png"></p>
<p>每次提交，<strong>master</strong>分支都会向前移动一步，这样，随着你不断提交，<strong>master</strong>分支的线也越来越长：<br>当我们创建新的分支，例如<strong>dev</strong>时，Git新建了一个指针叫<strong>dev</strong>，指向<strong>master</strong>相同的提交，再把<strong>HEAD</strong>指向<strong>dev</strong>，就表示当前分支在<strong>dev</strong>上：</p>
<p><img src="/posts/43167/git_2.1.1.png"></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<strong>dev</strong>指针，改改<strong>HEAD</strong>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<strong>dev</strong>分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p><img src="/posts/43167/git_2.1.2.png"></p>
<p>假如我们在<strong>dev</strong>上的工作完成了，就可以把<strong>dev</strong>合并到<strong>master</strong>上。Git怎么合并呢？最简单的方法，就是直接把<strong>master</strong>指向<strong>dev</strong>的当前提交，就完成了合并：</p>
<p><img src="/posts/43167/git_2.1.3.png"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<strong>dev</strong>分支。删除<strong>dev</strong>分支就是把<strong>dev</strong>指针给删掉，删掉后，我们就剩下了一条<strong>master</strong>分支：</p>
<p><img src="/posts/43167/git_2.1.4.png"></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建<strong>dev</strong>分支，然后切换到<strong>dev</strong>分支：</p>
<blockquote>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’</p>
</blockquote>
<p><strong>git checkout</strong>命令加上**-b**参数表示创建并切换，相当于以下两条命令：</p>
<blockquote>
<p>git branch dev<br>git checkout dev<br>Switched to branch ‘dev’</p>
</blockquote>
<p>然后，用<strong>git branch</strong>命令查看当前分支：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li>dev<br>  master</li>
</ul>
<p><strong>git branch</strong>命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>然后，我们就可以在<strong>dev</strong>分支上正常提交，比如对readme.txt做个修改，加上一行：然后提交：现在，dev分支的工作完成，我们就可以切换回master分支：</p>
<blockquote>
<p>$ git checkout master<br>Switched to branch ‘master’</p>
</blockquote>
<h3 id="2-2、合并分支"><a href="#2-2、合并分支" class="headerlink" title="2.2、合并分支"></a>2.2、合并分支</h3><p>切换回<strong>master</strong>分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在<strong>dev</strong>分支上，而<strong>master</strong>分支此刻的提交点并没有变：</p>
<p><img src="/posts/43167/git_2.2.png"></p>
<p>现在，我们把<strong>dev</strong>分支的工作成果合并到<strong>master</strong>分支上：</p>
<blockquote>
<p>$ git merge dev<br>Updating d46f35e..b17d20e<br>Fast-forward<br>readme.txt | 1 +<br>1 file changed, 1 insertion(+)</p>
</blockquote>
<p><strong>git merge</strong>命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和<strong>dev</strong>分支的最新提交是完全一样的。<br>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<strong>dev</strong>分支了</p>
<blockquote>
<p>$ git branch -d dev<br>Deleted branch dev (was b17d20e).</p>
</blockquote>
<p>删除后，查看<strong>branch</strong>，就只剩下<strong>master</strong>分支了：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li><p>master</p>
<p>  因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>
</li>
</ul>
<h3 id="2-3、git-merge后，后悔了如何回退"><a href="#2-3、git-merge后，后悔了如何回退" class="headerlink" title="2.3、git merge后，后悔了如何回退"></a>2.3、git merge后，后悔了如何回退</h3><p>如果合并一个分支到另一个分支中后后悔了，该怎么处理。总共分三步：<br>第一步：git checkout到你要恢复的那个分支上</p>
<blockquote>
<p>git checkout develop</p>
</blockquote>
<p>第二步：git reflog查出要回退到merge前的版本号</p>
<blockquote>
<p>git reflog</p>
</blockquote>
<p>第三步：git reset –hard [版本号]就回退到merge前的代码状态了</p>
<blockquote>
<p>git reset –hard f82cfd2</p>
</blockquote>
<p>至此回退代码的目标达成。</p>
<p><strong>小结</strong>：</p>
<blockquote>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name></name></p>
<p>创建+切换分支：git checkout -b <name></name></p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>删除分支：git branch -d <name></name></p>
</blockquote>
<h3 id="2-4、在分支中合并文件夹"><a href="#2-4、在分支中合并文件夹" class="headerlink" title="2.4、在分支中合并文件夹"></a>2.4、在分支中合并文件夹</h3><p>git小技巧–如何从其他分支merge个别文件或文件夹<br>在实际工作中，一个大型的项目或版本迭代可能不是一次上线，可能会分好几次上线，这时候就会涉及创建多个分支，进行分别开发。</p>
<p><strong>合并分支</strong><br>使用git merge 命令进行分支合并是通用的做法，但是git merge 合并的时候会将两个分支的内容完全合并，如果想合并一部分肯定是不行的。那怎么办？<br>如何从其他分支merge指定文件到当前分支，git checkout 是个合适的工具。</p>
<blockquote>
<p>git checkout source_branch &lt;path&gt;… </p>
</blockquote>
<p><strong>强制合并</strong><br>我们使用git checkout 将B分支上的系统消息功能添加到A分支上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch  * A     B</span>     </span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout B message.html message.css message.js other.js</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch A<span class="comment"># Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##    new file:   message.css#    new file:   message.html#    new file:   message.js#    modified:   other.js#</span></span></span><br></pre></td></tr></table></figure>

<p><strong>合并完成</strong><br>注意：在使用git checkout某文件到当前分支时，会将当前分支的对应文件强行覆盖<br>这里新增文件没问题，但是A分支上原有的other.js会被强行覆盖，如果A分支上的other.js有修改，在checkout的时候就会将other.js内容强行覆盖，这样肯定是不行的。如何避免不强制覆盖，往下看。<br><strong>智能合并</strong></p>
<ol>
<li>使用git checkout 将根据A分支创建一个A_temp分支，避免影响A分支</li>
</ol>
<blockquote>
<p>$ git checkout -b A_temp</p>
</blockquote>
<ol start="2">
<li>将B分支合并到A_temp分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Switched to a new branch &#x27;A_temp&#x27;</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge BUpdating 1f73596..04627b5Fast-forward message.css                     | 0 message.html                    | 0 message.js                      | 0 other.js                        | 1 + 4 files changed, 1 insertion(+) create mode 100644 message.css create mode 100644 message.html create mode 100644 message.js</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>切换到A分支，并使用git checkout 将A_temp分支上的系统消息功能相关文件或文件夹覆盖到A分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout ASwitched to branch <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout A_temp message.html message.css message.js other.js$ git status On branch A    Changes to be committed:	(use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)	new file:   message.css    new file:   message.html    new file:   message.js    modified:   other.js</span></span><br></pre></td></tr></table></figure>

<h2 id="3、标签管理"><a href="#3、标签管理" class="headerlink" title="3、标签管理"></a>3、标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”<br>“一串乱七八糟的数字不好找！”<br>如果换一个办法：<br>“请把上周一的那个版本打包发布，版本号是v1.2”<br>“好的，按照tag v1.2查找commit就行！”<br>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h3 id="3-1、创建标签"><a href="#3-1、创建标签" class="headerlink" title="3.1、创建标签"></a>3.1、创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：<br>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：<br><code>$ git tag v0.9 f52c633</code><br>再用命令<strong>git tag</strong>查看标签：</p>
<blockquote>
<p>$ git tag<br>v0.9<br>v1.0</p>
</blockquote>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：<br>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</tagname></p>
<blockquote>
<p>$ git tag -a v0.1 -m “version 0.1 released” 1094adb</p>
</blockquote>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<blockquote>
<p>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</tagname></p>
<p>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></p>
<p>命令git tag可以查看所有标签。</p>
</blockquote>
<h3 id="3-2、操作标签"><a href="#3-2、操作标签" class="headerlink" title="3.2、操作标签"></a>3.2、操作标签</h3><p>如果标签打错了也可以删除：</p>
<blockquote>
<p>$ git tag -d v0.1<br>Deleted tag ‘v0.1’ (was f15b0dd)</p>
</blockquote>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<blockquote>
<p>$ git push origin v1.0<br>Total 0 (delta 0), reused 0 (delta 0)<br>To github.com:michaelliao/learngit.git</p>
<ul>
<li>[new tag]         v1.0 -&gt; v1.0</li>
</ul>
</blockquote>
<p> 或者，一次性推送全部尚未推送到远程的本地标签：</p>
<blockquote>
<p>$ git push origin –tags<br>Total 0 (delta 0), reused 0 (delta 0)<br>To github.com:michaelliao/learngit.git</p>
<ul>
<li>[new tag]         v0.9 -&gt; v0.9</li>
</ul>
</blockquote>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<blockquote>
<p>$ git tag -d v0.9<br>Deleted tag ‘v0.9’ (was f52c633)</p>
</blockquote>
<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<blockquote>
<p>$ git push origin :refs/tags/v0.9<br>To github.com:michaelliao/learngit.git</p>
<ul>
<li>[deleted]         v0.9</li>
</ul>
</blockquote>
<blockquote>
<p>小节：</p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
</blockquote>
<h2 id="4、自定义git"><a href="#4、自定义git" class="headerlink" title="4、自定义git"></a>4、自定义git</h2><h3 id="4-1、忽略特殊文件"><a href="#4-1、忽略特殊文件" class="headerlink" title="4.1、忽略特殊文件"></a>4.1、忽略特殊文件</h3><p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">.gitignore</a><br>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<blockquote>
<p>$ git add App.class<br>The following paths are ignored by one of your .gitignore files:<br>App.class<br>Use -f if you really want to add them.</p>
</blockquote>
<p>如果你确实想添加该文件，可以用-f强制添加到Git：</p>
<blockquote>
<p>$ git add -f App.class</p>
</blockquote>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<blockquote>
<p>$ git check-ignore -v App.class<br>.gitignore:3:*.class    App.class</p>
</blockquote>
<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p>小结</p>
<blockquote>
<p>忽略某些文件时，需要编写<code>.gitignore</code>；<br><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>
</blockquote>
<h3 id="4-2、配置别名"><a href="#4-2、配置别名" class="headerlink" title="4.2、配置别名"></a>4.2、配置别名</h3><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p>
<blockquote>
<p>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”</p>
</blockquote>
<p>配置文件</p>
<p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON简介及C语言开发</title>
    <url>/posts/5299/</url>
    <content><![CDATA[<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p><strong>JSON</strong>全称(<strong>JavaScript</strong> <strong>Object</strong> <strong>Notation</strong>, JS 对象简谱)，是一种轻量级的数据交换格式。</p>
<p><strong>本质就是具有特定格式的字符串</strong>。</p>
<p><strong>JSON</strong>完全独立与编程语言，比<strong>XML</strong>数据传输的有效性要高很多</p>
<span id="more"></span>

<p><img src="/posts/5299/json.jpg" alt="json"></p>
<h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><p><strong>JSON</strong>分为两种大的类型：<strong>json数组</strong>和<strong>json对象</strong>，或者<strong>数组加对象</strong></p>
<ul>
<li><p><strong>json对象</strong></p>
<p>JSON 对象需要在大括号<code>&#123;  &#125;</code>中书写。对象可以包含多个 <strong>key/value（键/值）</strong>对。</p>
<p><strong>key 必须是字符串，不重复</strong>，</p>
<p><strong>value</strong> 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）</p>
<p><strong>key</strong> 和 <strong>value</strong> 中使用冒号<code>:</code>分割，每个 <strong>key/value</strong> 对使用逗号<code>,</code>分割</p>
<blockquote>
<p><strong>注：</strong>最后一个键值对后面没有<code>，</code></p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;runoob&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;alexa&quot;</span>:<span class="number">10000</span>,</span><br><span class="line">   <span class="attr">&quot;class&quot;</span>:&#123;<span class="attr">&quot;key1&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;key2&quot;</span>:<span class="number">2</span>&#125;,</span><br><span class="line">   <span class="attr">&quot;BOOL_T&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">   <span class="attr">&quot;BOOL_F&quot;</span>:<span class="literal">false</span>，</span><br><span class="line">   <span class="string">&quot;site&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>json数组</strong></p>
<p>JSON 数组在中括号<code>[  ]</code>中书写。</p>
<p>中括号[ <strong>整型</strong>，<strong>字符串</strong>，<strong>布尔类型</strong>，<strong>json数组</strong>，<strong>json对象</strong> ]</p>
<p>JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）</p>
<blockquote>
<p><strong>注：</strong>数组中最后一个元素后没有<code>，</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line">[</span><br><span class="line">    <span class="number">123</span>,</span><br><span class="line">    <span class="number">123.3</span>,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Runoob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Taobao&quot;</span>，</span><br><span class="line">    [<span class="literal">null</span>,<span class="string">&quot;json&quot;</span>]，</span><br><span class="line">    &#123;KEY:U&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="C语言json开源解析库-cJSON"><a href="#C语言json开源解析库-cJSON" class="headerlink" title="C语言json开源解析库-cJSON"></a>C语言json开源解析库-cJSON</h2><h3 id="cJSON的使用"><a href="#cJSON的使用" class="headerlink" title="cJSON的使用"></a>cJSON的使用</h3><ul>
<li>压缩包解压，直接使用里面的cJSON.c和cJSON.h即可</li>
<li>链接时需要加上<code>-lm</code>表示链接math库</li>
</ul>
<h3 id="创建json对象"><a href="#创建json对象" class="headerlink" title="创建json对象"></a>创建json对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个json对象</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateObject</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//向json对象中添加数据成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemToObject</span><span class="params">(cJSON *object,	<span class="comment">//json对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>,<span class="comment">//key值</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              cJSON *item)</span></span>;		<span class="comment">//value值（int, string，array，ogj）</span></span><br><span class="line"><span class="comment">//创建一个整型值</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateNumber</span><span class="params">(<span class="keyword">double</span> num)</span></span>;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateNull</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateTrue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateFalse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateBool</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//创建一个字符串</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateArray</span><span class="params">(<span class="keyword">void</span>)</span></span>;--空数组</span><br><span class="line"><span class="comment">//创建默认有count个整型值的json数组</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_CreateIntArray</span><span class="params">(<span class="keyword">int</span> *numbers,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">//向json数组中添加数据成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cJSON_AddItemToArray</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span></span>;</span><br><span class="line"><span class="comment">//释放json结构指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">cJSON_Delete</span><span class="params">(cJSON *c)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将json结构转化为字符串</span></span><br><span class="line"><span class="comment">返回值需要用free释放</span></span><br><span class="line"><span class="comment">可以将字符串写入文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>  *<span class="title">cJSON_Print</span><span class="params">(cJSON *item)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除json数据"><a href="#删除json数据" class="headerlink" title="删除json数据"></a>删除json数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="解析json数据"><a href="#解析json数据" class="headerlink" title="解析json数据"></a>解析json数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串解析为json结构</span></span><br><span class="line"><span class="comment">//返回值需要用cJSON_Delete释放</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_Parse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"><span class="comment">//根据键值查找json节点</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_GetObjectItem</span><span class="params">(cJSON *object,	<span class="comment">//当前json对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span><span class="comment">//key值</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          )</span></span>;</span><br><span class="line"><span class="comment">//获取json数组中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">cJSON_GetArraySize</span><span class="params">(cJSON *<span class="built_in">array</span>)</span></span>;</span><br><span class="line"><span class="comment">//根据数组下标找到对应的数组元素</span></span><br><span class="line"><span class="function">cJSON *<span class="title">cJSON_GetArrayItem</span><span class="params">(cJSON *<span class="built_in">array</span>,<span class="keyword">int</span> item)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改json数据"><a href="#修改json数据" class="headerlink" title="修改json数据"></a>修改json数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改数组中的元素，</span></span><br><span class="line"><span class="comment">//参数：array 数组</span></span><br><span class="line"><span class="comment">//which 要修改的数组元素的索引，0.1.2.3</span></span><br><span class="line"><span class="comment">//newitem 修改成新的元素</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_ReplaceItemInArray</span><span class="params">(cJSON *<span class="built_in">array</span>,<span class="keyword">int</span> which,cJSON *newitem)</span></span>;</span><br><span class="line"><span class="comment">//替换对象中“string”元组的值</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">cJSON_ReplaceItemInObject</span><span class="params">(cJSON *object,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>,cJSON *newitem)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="C语言json开源解析库-json-c"><a href="#C语言json开源解析库-json-c" class="headerlink" title="C语言json开源解析库-json-c"></a>C语言json开源解析库-json-c</h2><ul>
<li>软件环境说明：</li>
</ul>
<table>
<thead>
<tr>
<th>软件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>ubuntu16.04 32位</td>
</tr>
<tr>
<td>json-c版本</td>
<td>JSON-C-0.13.1</td>
</tr>
</tbody></table>
<ul>
<li>参考说明：</li>
</ul>
<p><strong>json-c安装说明</strong> <a href="http://www.linuxfromscratch.org/blfs/view/svn/general/json-c.html">^1</a></p>
<h3 id="json-c的使用"><a href="#json-c的使用" class="headerlink" title="json-c的使用"></a>json-c的使用</h3><ul>
<li>获取源码</li>
</ul>
<p>可到<a href="http://www.linuxfromscratch.org/blfs/view/svn/general/json-c.html">json-c</a>网站中下载<a href="https://s3.amazonaws.com/json-c_releases/releases/json-c-0.13.1.tar.gz">JSON-C-0.13.1</a>源码</p>
<ul>
<li>安装</li>
</ul>
<p>将源码解压后，进入到<code>json-c-0.13.1</code>文件夹中，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr --disable-static &amp;&amp; make</span><br></pre></td></tr></table></figure>

<p>可能会出现告警如下。说明系统中缺少json-c需要的包。<strong>autoconf</strong>，<strong>automake</strong>，<strong>libtool</strong></p>
<p>使用命令：<code>sudo apt-get install  autoconf automake libtool</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/work/test/jsonc/json-c-0.13.1/missing: 行 81: autoheader: 未找到命令</span><br><span class="line">WARNING: &#x27;autoheader&#x27; is missing on your system.</span><br><span class="line">You should only need it if you modified &#x27;acconfig.h&#x27; or</span><br><span class="line">&#x27;configure.ac&#x27; or m4 files included by &#x27;configure.ac&#x27;.</span><br><span class="line">The &#x27;autoheader&#x27; program is part of the GNU Autoconf package:</span><br><span class="line">&lt;http://www.gnu.org/software/autoconf/&gt;</span><br><span class="line">It also requires GNU m4 and Perl in order to run:</span><br><span class="line">&lt;http://www.gnu.org/software/m4/&gt;</span><br><span class="line">&lt;http://www.perl.org/&gt;</span><br><span class="line">Makefile:495: recipe for target &#x27;config.h.in&#x27; failed</span><br><span class="line">make: *** [config.h.in] Error 127</span><br></pre></td></tr></table></figure>
<p>编译通过后，可以使用 <strong>make check</strong>命令检查</p>
<p>最后使用<strong>root</strong>权限执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>命令解释</li>
</ul>
<blockquote>
<p><em><code>--disable-static</code></em>: 阻止安装库的静态版本。</p>
</blockquote>
<ul>
<li>安装内容</li>
</ul>
<ol>
<li>安装的软件： 无</li>
<li>安装的库文件：ibjson-c.so and libjson.so</li>
<li>安装的头文件：/usr/include/json and /usr/include/json-c</li>
</ol>
<h3 id="自测代码"><a href="#自测代码" class="headerlink" title="自测代码"></a>自测代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">json_object</span> *<span class="title">object</span>=</span>json_object_new_object();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">json_object</span> *<span class="title">json_string</span>=</span>json_object_new_string (<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> a=json_object_object_add (object, <span class="string">&quot;test&quot;</span>, json_string);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *object_string=json_object_to_json_string(object);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;object_string=%s\n&quot;</span>,object_string);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test json.c -ljson-c -I /usr/include/json-c/ -L /usr/lib/</span><br></pre></td></tr></table></figure>

<h3 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h3><p>参考：<a href="https://www.jianshu.com/p/659bb1b09f1b">JSON解析器json-c</a></p>
<h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3>]]></content>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>linux shell编程</title>
    <url>/posts/53574/</url>
    <content><![CDATA[<p><img src="/posts/53574/linux_shell.png" alt="linux_shell"></p>
<span id="more"></span>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式与通配符"><a href="#正则表达式与通配符" class="headerlink" title="正则表达式与通配符"></a>正则表达式与通配符</h3><p><strong>正则表达式</strong><code>用来在文件中匹配符合条件的字符串</code>，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。</p>
<p><strong>通配符</strong><code>用来匹配符合条件的文件名</code>，通配符是完全匹配。ls，find，cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。</p>
<h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*</code></td>
<td align="left">前一个字符匹配0次或多次。</td>
</tr>
<tr>
<td align="center"><code>.</code></td>
<td align="left">匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="left">匹配行首。例如：^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td align="left">匹配行尾。例如：hello&amp;会匹配以hello结尾的行。</td>
</tr>
<tr>
<td align="center"><code>[ ]</code></td>
<td align="left">匹配中括号中指定的任意一个字符，只匹配一个字符。<br>例如：<code>[aoelu]</code>匹配任意一个元音字母，<code>[0-9]</code>匹配任意一位数字，<br><code>[a-z] [0-9]</code> 匹配小写字和一位数字构成的两位字符。</td>
</tr>
<tr>
<td align="center"><code>[^]</code></td>
<td align="left">匹配除中括号的字符以外的任意一个字符。<br>例如:<code>[^0-9]</code>匹配任意一位非数字字符,<br><code>[^a-z]</code>表示任意一位非小写字母。</td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td align="left">转义符。用于取消讲特殊符号的含义取消。</td>
</tr>
<tr>
<td align="center"><code>\&#123;n\&#125;</code></td>
<td align="left">标识其前面的字符恰好出现n次。例如:<code>[09]\&#123;4\&#125;</code>匹配4位数字，<br><code>[1][3-8][0-9]\&#123;9\&#125;</code>匹配手机号码。</td>
</tr>
<tr>
<td align="center"><code>\&#123;n,\&#125;</code></td>
<td align="left">表示其前面的字符出现不小于n次。<br>例如:<code>[0-9]\&#123;2,\&#125;</code>表示两位及以上的数字。</td>
</tr>
<tr>
<td align="center"><code>\&#123;n,m\&#125;</code></td>
<td align="left">表示其前面的字符至少出现n次,最多出现m次。<br>例如:<code>[a-z]\&#123;6,8\&#125;</code>匹配6到8位的小写字母。</td>
</tr>
</tbody></table>
<p><code>grep &quot;^$&quot; xxx.txt</code>表示比配空白行，<code>grep -n &quot;^$&quot; xxx.txt</code>匹配空白行并打印行号。</p>
<h2 id="字符串截取命令-cut命令"><a href="#字符串截取命令-cut命令" class="headerlink" title="字符串截取命令-cut命令"></a>字符串截取命令-cut命令</h2><p>字段提取命令<strong>cut</strong>：cut [选项] 文件名，一般与<strong>grep</strong>联合使用。</p>
<ul>
<li>-f：列号，提取第几列</li>
<li>-d：分隔符，按照指定分隔符分割列；默认分隔符为制表符<code>/t</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>：但是<strong>cut</strong>命令是有局限性的，如果分隔符是空格，或多个空格，<strong>cut</strong>就不能很好的使用。</p>
</blockquote>
<h2 id="字符串截取命令-printf命令"><a href="#字符串截取命令-printf命令" class="headerlink" title="字符串截取命令-printf命令"></a>字符串截取命令-printf命令</h2><blockquote>
<p>printf ‘输出类型输出格式’ 输出内容</p>
</blockquote>
</li>
<li><strong>输出类型：</strong></li>
</ul>
<p>%ns：输出字符串。n是数字指定输出几个字符<br>%ni：输出整数。n是数字指定输出几个数字<br>%m.nf：输出浮点型。m和n是数字，指定输出的整数位数和小数位数。如***%8.2f***代表共输出8位数，其中2位是小数，6位是整数。</p>
<ul>
<li><strong>输出格式</strong></li>
</ul>
<blockquote>
<p>\a：输出警告声音<br>\b：输出退格键，Backspace键<br>\f：清除屏幕<br>\n：换行<br>\r：回车<br>\t：水平输出退格键，Tab键<br>\v：垂直输出退格键，Tab键</p>
</blockquote>
<p><strong>printf</strong>不能打印文件的内容，也不能通过管道符接收文件的内容。<strong>printf</strong>命令一般不会单独使用，都是在<strong>awk</strong>命令中使用，在系统中直接使用不多。</p>
<p>在<strong>awk</strong>命令中的输出支持<strong>print</strong>和<strong>printf</strong>命令</p>
<ul>
<li><p><strong>print</strong>：<strong>print</strong>会在每个输出后面自动加换行符（linux系统默认没有<strong>print</strong>命令）</p>
</li>
<li><p><strong>printf</strong>：<strong>printf</strong>是标准格式输出命令，并不会自动加换行符，如果需要换行，需要手动添加换行符。</p>
<h2 id="字符串截取命令-awk命令"><a href="#字符串截取命令-awk命令" class="headerlink" title="字符串截取命令-awk命令"></a>字符串截取命令-awk命令</h2></li>
<li><p><em>awk</em>* ‘条件1｛动作1｝ 条件2 ｛动作2｝ …’ 文件名</p>
</li>
<li><p>条件（Pattern）：</p>
<blockquote>
<p>一般使用关系表达式作为条件：<br>x&gt;10，x&lt;=10，x&gt;=10</p>
</blockquote>
</li>
<li><p>动作（Action）：</p>
<blockquote>
<p>格式化输出<br>流程控制语句</p>
</blockquote>
</li>
</ul>
<p><strong>awk</strong>虽然是列提取命令，但是<strong>awk</strong>是先读取一行数据，然后<strong>$1</strong>代表第一列数据，<strong>$2</strong>代表第二列数据，依次类推，<strong>$0</strong>代表正行数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印文件第2和第6列</span></span><br><span class="line">awk &#x27;&#123; printf 	\$2 &quot;\t&quot; \$6 &quot;\n&quot; &#125;&#x27; file.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">打印磁盘使用率</span></span><br><span class="line">df -h | grep ada5 | awk &#x27;&#123; printf $5 &#125;&#x27; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure>
<ul>
<li>BEGIN选项</li>
</ul>
<p>在进行真正的数据读取前先执行<strong>BEGIN</strong>中的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BUGIN &#123;print &quot;This is  a transctript&quot;&#125; &#123;print \$2 &quot;\t&quot; \$6 &#125; file.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>FS 内置变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;print \$1 &quot;\t&quot; \$3 &#125;&#x27;  /etc/passwd</span><br></pre></td></tr></table></figure>
<p>在读取数据前，先指定分隔符为“：”。如果不加<strong>BUGIN</strong>第一行会被全部打印出来，与期待结果不一致。</p>
</li>
<li><p>END</p>
</li>
</ul>
<p>在动作执行结束后执行xx命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; END&#123;print &quot;aaaaaaa&quot;&#125;&#123;print \$1 &quot;\t&quot; \$3 &#125;&#x27;  /etc/passwd</span><br></pre></td></tr></table></figure>
<h2 id="字符串截取命令-sed命令"><a href="#字符串截取命令-sed命令" class="headerlink" title="字符串截取命令-sed命令"></a>字符串截取命令-sed命令</h2><p><strong>sed</strong>是一种几乎包括在所有UNIX平台（包括linux）的轻量级流编辑器。<strong>sed</strong>主要是用来将数据进行选取、替换、删除、新增的命令。<br><strong>sed</strong> [选项] ‘[动作]’ 文件名</p>
<blockquote>
<p>选项：<br><code>-n</code>：一般sed命令会把所有数据输出到屏幕。如果加了该选项，则只会把经过sed命令处理过的行输出到屏幕；<br><code>-e</code>：允许多个条件同时执行，不同条件之间用<code>；</code>隔开；<br><code>-i</code>：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出；</p>
</blockquote>
<hr>
<blockquote>
<p>动作：<br>a\：追加，在当前行后面增加一行或多行。增加多行时，除最后一行外，每行末尾需要加“\”代表数据未完结；<br>c\：行替换，用<code>c</code>后面的字符串替换源数据行，替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结；<br>i\：插入，在当前行前插入一行或多行，插入多行时，除最后一行外，每行末尾需用“\”代表数据未完结；<br>d：删除；<br>p：打印，输出指定的行；<br>s：字符串替换，用一个字符串替换另一个字符串。格式为<code>行范围s/旧字串/新字串、g</code>（和vim中的替换格式类似）</p>
</blockquote>
<ol>
<li>行数据操作<br><strong>sed -n ‘2p’ file.txt</strong>：打印文件第二行，加-n选项只打印第二行，否则会打印全部文件。</li>
<li>文件删除<br><strong>sed ‘2,3d’ file.txt</strong>：删除文件2-3行，只影响输出结果，不影响文件本身。 </li>
<li>文件追加<br><strong>sed ‘2a hello’ file.txt <strong>:在文件第2行后面加入</strong>hello</strong><br><strong>sed ‘2i  hello’ file.txt <strong>:在文件第2行前面加入</strong>hello</strong></li>
<li>行替换<br><strong>sed ‘4c no person’ file.txt</strong>：将第4行数据替换为<strong>no persion</strong></li>
<li>字符串替换<br><strong>sed ’3s/77/99/g‘ file.txt</strong>：将第3行的77替换为99<br><strong>sed -e ‘s/gao//g;s/chao//g’ file.txt</strong>     <h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2></li>
</ol>
<h3 id="排序命令sort"><a href="#排序命令sort" class="headerlink" title="排序命令sort"></a>排序命令<strong>sort</strong></h3><p><code> sort [选项] 文件名</code></p>
<blockquote>
<p>选项：</p>
<ul>
<li>-f：忽略大小写</li>
<li>-n：以数值型进行排序，默认使用字符串排序</li>
<li>-r：反向排序</li>
<li>-t：指定分隔符，默认使用制表符</li>
<li>-k n[,m]：按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）</li>
<li>-u：去除重复行 </li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用：为分隔符，以第三个字段排序，以数值型排序</span></span><br><span class="line">sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br></pre></td></tr></table></figure>
<h3 id="统计命令wc"><a href="#统计命令wc" class="headerlink" title="统计命令wc"></a>统计命令<strong>wc</strong></h3><p><code>wc [选项] 文件名</code></p>
<blockquote>
<p>选项：</p>
<ul>
<li>-l：只统计行数</li>
<li>-w：只统计单词数</li>
<li>-m：只统计字符数</li>
</ul>
</blockquote>
<hr>
<h3 id="替换命令tr"><a href="#替换命令tr" class="headerlink" title="替换命令tr"></a>替换命令tr</h3><p><code>tr [OPTION]... SET1 [SET2]</code></p>
<p>选项：</p>
<ul>
<li><p>-s：替换重复的字符</p>
</li>
<li><p>-d：删除字符</p>
</li>
</ul>
<blockquote>
<p>-d：delete，删除SET1中指定的所有字符，不转换</p>
</blockquote>
<ul>
<li>-t：字符替换</li>
</ul>
<blockquote>
<p>-t：truncate，将SET1中字符用SET2对应位置的字符进行替换，一般缺省为-t</p>
</blockquote>
<ul>
<li>-c：字符补集替换</li>
</ul>
<blockquote>
<p>-c：complement，用SET2替换SET1中没有包含的字符</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将空格替换为换行符</span></span><br><span class="line">aston@work:~/shell/suanfa$ cat words.txt </span><br><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br><span class="line">aston@work:~/shell/suanfa$ cat words.txt | tr -s &#x27; &#x27; &#x27;\n&#x27;</span><br><span class="line">the</span><br><span class="line">day</span><br><span class="line">is</span><br><span class="line">sunny</span><br><span class="line">the</span><br><span class="line">the</span><br><span class="line">the</span><br><span class="line">sunny</span><br><span class="line">is</span><br><span class="line">is</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_shell1</title>
    <url>/posts/40073/</url>
    <content><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断文件是否存在</span></span><br><span class="line">test -e file.txt</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<h3 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h3><table>
<thead>
<tr>
<th align="center">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-b文件</td>
<td align="center">判断文件是否存在，并且是否是块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td align="center">-c文件</td>
<td align="center">判断文件是否存在，并且是否是字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td align="center"><strong>-d文件</strong></td>
<td align="center"><strong>判断文件是否存在，并且是否为目录文件（是目录文件为真）</strong></td>
</tr>
<tr>
<td align="center"><strong>-e文件</strong></td>
<td align="center"><strong>判断文件是否存在（存在为真）</strong></td>
</tr>
<tr>
<td align="center"><strong>-f文件</strong></td>
<td align="center"><strong>判断文件是否存在，并且是否为普通文件（是普通文件为真）</strong></td>
</tr>
<tr>
<td align="center">-L文件</td>
<td align="center">判断文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td align="center">-p文件</td>
<td align="center">判断文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td align="center">-s文件</td>
<td align="center">判断文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td align="center">-S文件</td>
<td align="center">判断文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<p><code>[ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</code></p>
<h3 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h3><table>
<thead>
<tr>
<th align="center">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-r文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td>
</tr>
<tr>
<td align="center">-w文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td>
</tr>
<tr>
<td align="center">-x文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td>
</tr>
<tr>
<td align="center">-u文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td align="center">-g文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td align="center">-k文件</td>
<td align="center">判断文件是否存在，并且是否该文件拥有SBit权限（有SBit权限为真）</td>
</tr>
</tbody></table>
<h3 id="两个文件之间比较"><a href="#两个文件之间比较" class="headerlink" title="两个文件之间比较"></a>两个文件之间比较</h3><table>
<thead>
<tr>
<th align="center">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件1 -nt 文件2</td>
<td align="center">判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td align="center">文件1 -ot 文件2</td>
<td align="center">判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td align="center">文件1 -ef 文件2</td>
<td align="center">判断文件1是否和文件2的<strong>lnode</strong>号一致，理解为两个文件是否为同一个文件。用于判断硬链接</td>
</tr>
</tbody></table>
<h3 id="两个整数比较"><a href="#两个整数比较" class="headerlink" title="两个整数比较"></a>两个整数比较</h3><table>
<thead>
<tr>
<th align="left">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">整数1 -eq 整数2</td>
<td align="center">判断两个整数是否相等（相等为真）</td>
</tr>
<tr>
<td align="left">整数1 -ne 整数2</td>
<td align="center">判断两个整数是否不相等（不相等为真）</td>
</tr>
<tr>
<td align="left">整数1 -gt 整数2</td>
<td align="center">判断整数1是否大于整数2（大于为真）</td>
</tr>
<tr>
<td align="left">整数1 -lt 整数2</td>
<td align="center">判断整数1是否小于整数2（小于为真）</td>
</tr>
<tr>
<td align="left">整数1 -ge 整数2</td>
<td align="center">判断整数1是否大于等于整数2（大于等于为真）</td>
</tr>
<tr>
<td align="left">整数1 -le 整数2</td>
<td align="center">判断整数1是否小于等于整数2（小于等于为真）</td>
</tr>
</tbody></table>
<h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><table>
<thead>
<tr>
<th align="left">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-z字符串</td>
<td align="center">判断字符串是否为空（为空返回真）</td>
</tr>
<tr>
<td align="left">-n字符串</td>
<td align="center">判断字符串是否非空（非空返回真）</td>
</tr>
<tr>
<td align="left">字符串1 == 字符串2</td>
<td align="center">判断字符串1是否和字符串2相等（相等返回真）</td>
</tr>
<tr>
<td align="left">字符串1 != 字符串2</td>
<td align="center">判断字符串1是否和字符串2不相等（不相等返回真）</td>
</tr>
</tbody></table>
<h3 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h3><table>
<thead>
<tr>
<th align="left">测试选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">判断1 -a 判断2</td>
<td align="center">逻辑与，判断1和2都成立为真</td>
</tr>
<tr>
<td align="left">判断1 -o 判断2</td>
<td align="center">逻辑或，判断1和2有一个成立为真</td>
</tr>
<tr>
<td align="left">！判断</td>
<td align="center">逻辑非，使原始的判断取反</td>
</tr>
</tbody></table>
<h2 id="流程控制-if语句"><a href="#流程控制-if语句" class="headerlink" title="流程控制-if语句"></a>流程控制-if语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">    程序</span><br><span class="line">fi</span><br><span class="line">或者</span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>if</strong>语句使用<strong>fi</strong>结尾；</li>
<li>[ 条件判断式 ]就是使用<strong>test</strong>命令判断，所以中括号与判断式之间必须有空格 ；</li>
<li><strong>then</strong>后面跟符合条件之后执行的程序，可以放在[]后面用<code>；</code>隔开，也可以换行写，不需要<code>；</code>。</li>
</ul>
<h2 id="流程控制-case语句"><a href="#流程控制-case语句" class="headerlink" title="流程控制-case语句"></a>流程控制-case语句</h2><p>多分支case条件语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span> something</span></span><br><span class="line">	;;</span><br><span class="line">	&quot;值2&quot;)</span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span> something</span></span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line"><span class="meta">	#</span><span class="bash">other to <span class="keyword">do</span> somethong</span></span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="流程控制-for循环"><a href="#流程控制-for循环" class="headerlink" title="流程控制-for循环"></a>流程控制-for循环</h2><ul>
<li>语法1</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ul>
<li>语法2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( 初始值；循环条件；变量变化 ))</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="流程控制-while循环和unite循环"><a href="#流程控制-while循环和unite循环" class="headerlink" title="流程控制-while循环和unite循环"></a>流程控制-while循环和unite循环</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环是不定循环，也称条件循环。只要条件判断式成立，循环就一直继续，直到条件判断式不成立，循环才停止。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do </span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span></span> </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="unite循环"><a href="#unite循环" class="headerlink" title="unite循环"></a>unite循环</h3><p>unite循环和while循环相反，unite循环是只要条件判断式不成立则进行循环。一旦循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unite [ 条件判断式 ]</span><br><span class="line">do </span><br><span class="line"><span class="meta">	#</span><span class="bash">to <span class="keyword">do</span></span> </span><br><span class="line">done</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
